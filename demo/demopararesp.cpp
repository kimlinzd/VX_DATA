#include "demopararesp.h"
#include "appcommon.h"
#include "configmgr.h"
#include "misc/log.h"
#include "misc/easybuff.h"
#include <QTime>

static quint8 eDemoWaveResp[256] =  {
0x80,0x81,0x83,0x85,0x86,0x88,0x8A,0x8B,0x8D,0x8F,0x91,0x92,0x94,0x95,0x97,0x99,
0x9A,0x9C,0x9D,0x9F,0xA0,0xA2,0xA3,0xA5,0xA6,0xA8,0xA9,0xAB,0xAC,0xAD,0xAF,0xB0,
0xB1,0xB2,0xB3,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBC,0xBD,0xBE,0xBF,0xBF,
0xC0,0xC1,0xC1,0xC2,0xC2,0xC3,0xC3,0xC4,0xC4,0xC4,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,
0xC6,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC4,0xC4,0xC4,0xC3,0xC3,0xC2,0xC2,0xC1,0xC1,
0xC0,0xBF,0xBF,0xBE,0xBD,0xBC,0xBC,0xBB,0xBA,0xB9,0xB8,0xB7,0xB6,0xB5,0xB3,0xB2,
0xB1,0xB0,0xAF,0xAD,0xAC,0xAB,0xA9,0xA8,0xA6,0xA5,0xA3,0xA2,0xA0,0x9F,0x9D,0x9C,
0x9A,0x99,0x97,0x95,0x94,0x92,0x91,0x8F,0x8D,0x8B,0x8A,0x88,0x86,0x85,0x83,0x81,
0x80,0x7E,0x7C,0x7A,0x79,0x77,0x75,0x74,0x72,0x70,0x6E,0x6D,0x6B,0x6A,0x68,0x66,
0x65,0x63,0x62,0x60,0x5F,0x5D,0x5C,0x5A,0x59,0x57,0x56,0x54,0x53,0x52,0x50,0x4F,
0x4E,0x4D,0x4C,0x4A,0x49,0x48,0x47,0x46,0x45,0x44,0x43,0x43,0x42,0x41,0x40,0x40,
0x3F,0x3E,0x3E,0x3D,0x3D,0x3C,0x3C,0x3B,0x3B,0x3B,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,
0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3B,0x3B,0x3B,0x3C,0x3C,0x3D,0x3D,0x3E,0x3E,
0x3F,0x40,0x40,0x41,0x42,0x43,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4C,0x4D,
0x4E,0x4F,0x50,0x52,0x53,0x54,0x56,0x57,0x59,0x5A,0x5C,0x5D,0x5F,0x60,0x62,0x63,
0x65,0x66,0x68,0x6A,0x6B,0x6D,0x6E,0x70,0x72,0x74,0x75,0x77,0x79,0x7A,0x7C,0x7E
};

DemoParaResp::DemoParaResp(qreal sample) : DemoParaBase(sample)
{
    m_orderNums = 0;
    initDefSetInfo();
    m_buf = nullptr;
}

void DemoParaResp::initDefSetInfo()
{
    ConfigMgr::instance()->getRespSet(m_demoRespSet);
    m_demoRespGain = m_demoRespSet.Gain;
}

void DemoParaResp::getDemodata()
{
    if(m_buf == nullptr)
    {
        m_buf = EasyBuff::instance()->newBulkBuf_Resp();
        m_bufIndex = 0;
    }

    qint32 value = qint32(eDemoWaveResp[m_orderNums] << 4);
    m_orderNums =(m_orderNums + 1) % 256;
    switch (m_demoRespGain)
    {
        case RESP_GAIN_125:
        {
            value = qint32(0x800 + (value-0x800) * 0.125);
        }
        break;
        case RESP_GAIN_025:
        {
            value = qint32(0x800 + (value-0x800) * 0.25);
        }
        break;
        case RESP_GAIN_005:
        {
            value = qint32(0x800 + (value-0x800) * 0.5);
        }
        break;
        case RESP_GAIN_200:
        {
             value = qint32(0x800 + (value-0x800) * 2.0);
        }
        break;
        case RESP_GAIN_400:
        {
            value = qint32(0x800 + (value-0x800) * 4.0);
        }
        break;
        default:
            break;
    }
    if (value < 0)
    {
        value = 0;
    }
    else if (value > 0xFFF)
    {
        value = 0xFFF;
    }

    if ((m_orderNums % 63) == 0)
    {
        bool isApnea = false;
        qint8 rrValue = 15;
        QByteArray rrData;
        rrData.append(isApnea);
        rrData.append(rrValue);
        emit sig_ParaData(MRESP, 0x02, rrData);
    }

    m_demoRespWave = quint16(value);
    QByteArray wavedata;
    bool isLungBeat = false;
    if((m_orderNums % 250) == 0)
    {
        isLungBeat = true;
    }

    quint8* buf = m_buf + m_bufIndex * 3;
    *(buf++) = quint8(m_demoRespWave >> 8);
    *(buf++) = quint8(m_demoRespWave & 0x0FF);
    *buf = isLungBeat;
    m_bufIndex++;
    if(m_bufIndex >= BUFF_NUM_RESP)
    {
        sig_ParaDataPtr(MRESP, 1, m_buf);
        m_buf = nullptr;
        m_bufIndex = 0;
    }
}

void DemoParaResp::slot_SetInfo(qint32 paramod, qint32 cmd, const QByteArray &data)
{
    if((MRESP != paramod) || (0x02 != cmd))
    {
        return;
    }
    // Gain
    m_demoRespGain = quint8(data[0]);
}
