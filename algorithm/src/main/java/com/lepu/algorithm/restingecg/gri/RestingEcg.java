package com.lepu.algorithm.restingecg.gri;

import android.content.Context;
import android.util.Log;
//import android.widget.TextView;
//import android.widget.Toast;
//import java.util.ArrayList;
//import java.util.Collections;
//import java.util.List;
//import android.content.DialogInterface;


/**
 * Handles the set-up of ECG data for analysis and processes the analysis results
 * generated once the C analysis library as processed the ECG data.
 * 
 * @author Brian Devine
 *
 */
public class RestingEcg
{
	// --------------------------------------------------------------------------	
	private static final String TAG = "MyActivity-RestingEcg";
	// --------------------------------------------------------------------------	

	/**
	 * Value use to denote a measurement value that is undefined.
	 */
	public static final short GRI_UNDEFINED = (-32768);

	static final short GRI_UNDEFINED_2 = 0;

	/**
	 * The maximum number of leads that can be accommodated. This should not be
	 * changed as it is based on the maximum number of leads that the C ECG
	 * analysis library can handle.
	 */
	static final short GRI_MAX_ECG_LEADS = 15;
	
	/**
	 * The maximum number of samples that can be accommodated in a single raw
	 * ECG lead. This should not be changed as it is based on the maximum number
	 * of samples that the C ECG analysis library can handle. 
	 */
	static final short GRI_ECG_SAMPLES = 5000;
	static final short GRI_COMPLEX_SAMPLES = 600;

	static final short GRI_MAX_PACER_SPIKES = 100;
	static final short GRI_MAX_QRS = 50;
	static final short GRI_MAX_TUPLES = 50;
	
	
	/**
	 * Library error returns.
	 */
	static final int E_GRI_OK = 0;
	
	/**
	 * Bad parameter supplied to analysis library.
	 */
	static final int E_PROC_BADPARAM = 1;
	
	/**
	 * Memory initialisation error in library
	 */
	static final int E_PROC_MEMINIT = 2;
	
	/**
	 * Error when loading ECG data for analysis in library
	 */
	static final int E_PROC_LOADECG = 3;
	
	/**
	 * Error accessing java object/field values in library
	 */
	static final int E_PROC_JAVAFIELD = 4;

	static final int E_QRSFND_NOQRS = 1101;
	static final int E_AVERAG_NOQRS = 1401;
	static final int E_WAVTYP_ALIGN = 1301;
	static final int E_WAVTYP_MAXCLASS = 1302;
	static final int E_WAVTYP_ALIGN_WIDE = 1303;
	static final int E_AVERAG_MODE = 1402;

	static final int EXIT_LEAD_PLACE = 10;
	static final int EXIT_CMPLX_CALIBRATION = 11;
	static final int EXIT_ECG_CALIBRATION = 12;
	static final int EXIT_LEAD_AVAIL = 13;
	static final int EXIT_LOW_QRS_COUNT = 14;
	static final int EXIT_WAV_LEAD_AVAIL = 15;
	static final int EXIT_HIGH_QRS_COUNT = 16;
	static final int EXIT_ZERO_DURATION = 17;
	

	/**
	 * The {@link Context} for the current application. This is required
	 * for accessing the statement dictionary contained within the strings.xml
	 * resource.
	 */
	private Context appContext;
	
	
	/**
	 * This path is used by the C analysis library to determine where any
	 * debug logs/analysis results should be written. 
	 */
	String ResultsDir;
	

	/**
	 * The analysis status returned directly by the C ECG analysis library.
	 */
	long 	LibAnalysisStatus;

	EcgDataFileName EcgDataFiles;


	/**
	 * Information used to control the operation of the analysis
	 */
	ControlInfo controlInfo;

	// ----------------------------------------------------------------------
	// Data to be analysed (Input only)
	// ----------------------------------------------------------------------

	/**
	 * Patient information that does not change for different ECGs.
	 */
	PatientInfo		patientInfo;
	
	/**
	 * ECG recording information for the current ECG.
	 */
	RecordingInfo recordingInfo;
	
	/**
	 * ECG parameters for the current ECG.
	 */
	EcgInfo ecgInfo;
	
	/**
	 * Pacemaker spike information for the current ECG.
	 */
	PacemakerInfo	pacerInfo;

	// ----------------------------------------------------------------------
	// Data for processing (Input and output)
	// ----------------------------------------------------------------------
	
	/**
	 * All ECG leads used by and generated by the analysis.
	 */
	EcgLead[]		ecgLeads;
	

	// ----------------------------------------------------------------------
	// Analysis results (Output only)
	// ----------------------------------------------------------------------

	/**
	 * Beat identification information determined during the analysis.
	 * Includes information 
	 */
	BeatInfo		beatInfo;
	SpatialVelocity	spatialVelocity;
	MeasMatrix		measMatrix;
	StatementTuples statementTuples;
	SerialData serialData;

//	QrsList			qrsList;



	// ----------------------------------------------------------------------
	// NDK functions utilised by this class
	// ----------------------------------------------------------------------
	public native long jGriAnalysed();
	  
	static {
		System.loadLibrary("GlasgowEcg");
	}

	// ----------------------------------------------------------------------
	// METHODS
	// ----------------------------------------------------------------------

	public static int getStringIdentifier(Context context, String name)
	{
	    return context.getResources().getIdentifier(name, "string", context.getPackageName());
	}
	
	// ----------------------------------------------------------------------

	public static int getStringArrayIdentifier(Context context, String name)
	{
	    return context.getResources().getIdentifier(name, "array", context.getPackageName());
	}
	
	// ----------------------------------------------------------------------

	/**
	 * Creates and initialises the RestingEcg instance. The application
	 * context is required to enable the interpretation results from the
	 * analysis to be mapped to the appropriate interpretation statements
	 * stored withing the Strings resource.
	 * 
	 * @param current	The application context.
	 */
	public RestingEcg(Context current)
	{
		short	i;
	
		
		this.appContext           = current;
		this.ResultsDir           = "./";
		
		this.LibAnalysisStatus    = 0;
		
		
		// ------------------------------------------------------------------
		// Prepare input structures/parameters
		// ------------------------------------------------------------------

		this.controlInfo          = new ControlInfo();
		this.patientInfo          = new PatientInfo();
		this.ecgInfo              = new EcgInfo();
		this.recordingInfo        = new RecordingInfo();

		this.pacerInfo            = new PacemakerInfo( RestingEcg.GRI_MAX_PACER_SPIKES );


		// ------------------------------------------------------------------
		// Prepare structures used for input/output
		// ------------------------------------------------------------------

		this.ecgLeads = new EcgLead[RestingEcg.GRI_MAX_ECG_LEADS];
		for (i = 0; i < RestingEcg.GRI_MAX_ECG_LEADS; i++ )
		{
			ecgLeads[i] = new EcgLead( (short) GRI_ECG_SAMPLES, (short) GRI_COMPLEX_SAMPLES );
		}

		
		// ------------------------------------------------------------------
		// Prepare output structures
		// ------------------------------------------------------------------
		
		this.measMatrix           = new MeasMatrix();
		this.statementTuples      = new StatementTuples( GRI_MAX_TUPLES );
		this.serialData           = new SerialData();
		this.spatialVelocity      = new SpatialVelocity();
		this.beatInfo             = new BeatInfo();

	}

	// ----------------------------------------------------------------------

	/**
	 * Loads ECG data from a Glasgow GRIANLYS format input file and populates
	 * the elements of RestingEcg.
	 * 
	 * @param GriAscData	The name of the Glasgow GRIANLYS ECG data file.
	 * @return	Returns TRUE if the file was successfully read, otherwise returns FALSE.
	 */
	public boolean LoadFromGriAsc( GriAsc GriAscData )
	{
		short	i;
		GriLeadId[]	LeadConfig;

		
		// ------------------------------------------------------------------
		// Load data from the ASCII data file
		// ------------------------------------------------------------------
		//GriAscData.PrintContent();


		// Lead configuration info will be used later to set ecgInfo,
		// leadMeas and ecgLead.
		LeadConfig = GriAscData.getLeadConfig();

		// ------------------------------------------------------------------
		// Set up the controlInfo instance - INCOMPLETE
		// ------------------------------------------------------------------
		controlInfo.setBradycardiaLimit( GriAscData.getBradycardiaLimit() );
		controlInfo.setTachycardiaLimit( GriAscData.getTachycardiaLimit() );
//		controlInfo.setDemographicDefaults( 'M', 'C', 50, 'M', 'C', 365 );
		controlInfo.setLeadAvailability( GriAscData.getLeadAvailability() );
		controlInfo.setQTcFormula( GriAscData.getQTcFormula() );
		// ------------------------------------------------------------------
		// Set up the pacerInfo instance
		// ------------------------------------------------------------------
		pacerInfo.addPacers( GriAscData.getPacers() );

		// ------------------------------------------------------------------
		// Set up the patientInfo instance
		// ------------------------------------------------------------------
		patientInfo.setId( GriAscData.getId() );
		patientInfo.setFirstName( GriAscData.getFirstName() );
		patientInfo.setLastName( GriAscData.getLastName() );
		patientInfo.setRace( GriAscData.getRace() );
		patientInfo.setGender( GriAscData.getGender() );
		patientInfo.setBirthDate( GriAscData.getDateOfBirth() );


		// ------------------------------------------------------------------
		// Set up the ecgInfo instance
		// ------------------------------------------------------------------
		ecgInfo.setEcgSamplingFrequency( GriAscData.getSamplingFrequency() );
		ecgInfo.setElectrodePositioning( GriAscData.getElectrodePositioning() );
		ecgInfo.setLSBPerMV( GriAscData.getLSBPerMV() );
		ecgInfo.setMainsFilterToApply( GriAscData.getMainsFilterFrequency() );
		ecgInfo.setNumberOfLeads( GriAscData.getNumberOfLeads() );
		ecgInfo.setEcgSamplesPerLead( GriAscData.getSamplesPerLead() );
		ecgInfo.setLeadConfig( GriAscData.getLeadConfig() );

		
		// ------------------------------------------------------------------
		// Set up the recordingInfo instance
		// ------------------------------------------------------------------
		recordingInfo.SetAgeDays( GriAscData.getAgeDays() );
		recordingInfo.SetRecordingDate( GriAscData.getDateOfRecording() );
		recordingInfo.SetRecordingTime( GriAscData.getRecordingTime() );
		recordingInfo.SetDrugs( GriAscData.getDrug(0), GriAscData.getDrug(1) );
		recordingInfo.SetClinicalClassification( GriAscData.getClinicalClassification(0), GriAscData.getClinicalClassification(1) );
		
		
		// ------------------------------------------------------------------
		// Finally, set up the lead data instance and lead identifiers
		// ------------------------------------------------------------------
		for ( i = 0; i < GriAscData.getNumberOfLeads(); i++ )
		{
			ecgLeads[i].setIntLeadData( GriAscData.getLeadData(i) );
			ecgLeads[i].setLeadId( LeadConfig[i] );
			ecgLeads[i].setRecorded();					// All leads are recorded
			ecgLeads[i].setNotDerived();				// None of them are derived (for just now)
			ecgLeads[i].setNotNoisy();					// No leads are noisy - let the library decide
			if ( controlInfo.isLeadAvailable( ecgLeads[i].getLeadId(), ecgInfo.isPaediatricElectrodePlacement()))
			{
				ecgLeads[i].setAvailable();
			}
			else
			{
				ecgLeads[i].setUnavailable();
			}
			measMatrix.leadMeas[i].setLeadId( LeadConfig[i] );

		}

	
		return true;
	}
	public GriAsc LoadFromGriAsc( String FileName )
	{
		short	i;
		GriLeadId []	LeadConfig;
		GriAsc GriAscData = new GriAsc( );


		// ------------------------------------------------------------------
		// Load data from the ASCII data file
		// ------------------------------------------------------------------
		GriAscData.LoadFromFile( FileName );
		//GriAscData.PrintContent();


		// Lead configuration info will be used later to set ecgInfo,
		// leadMeas and ecgLead.
		LeadConfig = GriAscData.getLeadConfig();

		// ------------------------------------------------------------------
		// Set up the controlInfo instance - INCOMPLETE
		// ------------------------------------------------------------------
		controlInfo.setBradycardiaLimit( GriAscData.getBradycardiaLimit() );
		controlInfo.setTachycardiaLimit( GriAscData.getTachycardiaLimit() );
//		controlInfo.setDemographicDefaults( 'M', 'C', 50, 'M', 'C', 365 );
		controlInfo.setLeadAvailability( GriAscData.getLeadAvailability() );
		controlInfo.setQTcFormula( GriAscData.getQTcFormula() );

		// ------------------------------------------------------------------
		// Set up the pacerInfo instance
		// ------------------------------------------------------------------
		pacerInfo.addPacers( GriAscData.getPacers() );

		// ------------------------------------------------------------------
		// Set up the patientInfo instance
		// ------------------------------------------------------------------
		patientInfo.setId( GriAscData.getId() );
		patientInfo.setFirstName( GriAscData.getFirstName() );
		patientInfo.setLastName( GriAscData.getLastName() );
		patientInfo.setRace( GriAscData.getRace() );
		patientInfo.setGender( GriAscData.getGender() );
		patientInfo.setBirthDate( GriAscData.getDateOfBirth() );


		// ------------------------------------------------------------------
		// Set up the ecgInfo instance
		// ------------------------------------------------------------------
		ecgInfo.setEcgSamplingFrequency( GriAscData.getSamplingFrequency() );
		ecgInfo.setElectrodePositioning( GriAscData.getElectrodePositioning() );
		ecgInfo.setLSBPerMV( GriAscData.getLSBPerMV() );
		ecgInfo.setMainsFilterToApply( GriAscData.getMainsFilterFrequency() );
		ecgInfo.setNumberOfLeads( GriAscData.getNumberOfLeads() );
		ecgInfo.setEcgSamplesPerLead( GriAscData.getSamplesPerLead() );
		ecgInfo.setLeadConfig( GriAscData.getLeadConfig() );


		// ------------------------------------------------------------------
		// Set up the recordingInfo instance
		// ------------------------------------------------------------------
		recordingInfo.SetAgeDays( GriAscData.getAgeDays() );
		recordingInfo.SetRecordingDate( GriAscData.getDateOfRecording() );
		recordingInfo.SetRecordingTime( GriAscData.getRecordingTime() );
		recordingInfo.SetDrugs( GriAscData.getDrug(0), GriAscData.getDrug(1) );
		recordingInfo.SetClinicalClassification( GriAscData.getClinicalClassification(0), GriAscData.getClinicalClassification(1) );


		// ------------------------------------------------------------------
		// Finally, set up the lead data instance and lead identifiers
		// ------------------------------------------------------------------
		for ( i = 0; i < GriAscData.getNumberOfLeads(); i++ )
		{
			ecgLeads[i].setIntLeadData( GriAscData.getLeadData(i) );
			ecgLeads[i].setLeadId( LeadConfig[i] );
			ecgLeads[i].setRecorded();					// All leads are recorded
			ecgLeads[i].setNotDerived();				// None of them are derived (for just now)
			ecgLeads[i].setNotNoisy();					// No leads are noisy - let the library decide
			if ( controlInfo.isLeadAvailable( ecgLeads[i].getLeadId(), ecgInfo.isPaediatricElectrodePlacement()))
			{
				ecgLeads[i].setAvailable();
			}
			else
			{
				ecgLeads[i].setUnavailable();
			}
			measMatrix.leadMeas[i].setLeadId( LeadConfig[i] );

		}


		return GriAscData;
	}
	// ----------------------------------------------------------------------

	/**
	 * Retrieves the analysis status that was returned by the C ECG analysis
	 * library. This status value is more detailed by giving the exact error
	 * number from the C library rather than the generic error code that is
	 * returned from the {@link } method.
	 * 
	 * @return	The analysis status generated by the C ECG analysis library.
	 */
	public long getAnalysisStatus()
	{
		return this.LibAnalysisStatus;
	}

	// ----------------------------------------------------------------------

	/**
	 * Maps the C analysis library error return status to a {@link AnalysisStatus}
	 * enumerated type.
	 * 
	 * @return	The {@link AnalysisStatus} equivalent of the library error status.
	 */
	public AnalysisStatus simplifyAnalysisStatus()
	{
		AnalysisStatus	FinalStatus;
		int				intStatus;

		
		// Need to convert to int to use case. Not an issue as the error return
		// does not exceed the size of int.
		intStatus = (int) this.LibAnalysisStatus;
		
		
		// Map to simplified error return
		switch ( intStatus )
		{
			case E_GRI_OK:	FinalStatus = AnalysisStatus.GRIERR_OK;
							break;
			case E_PROC_BADPARAM:
			case E_PROC_MEMINIT:
			case E_PROC_LOADECG:
							FinalStatus = AnalysisStatus.GRIERR_PROC_INIT;
							break;
			case E_PROC_JAVAFIELD:
							FinalStatus = AnalysisStatus.GRIERR_PROC_JAVAFIELD;
							break;
			case E_QRSFND_NOQRS:
			case E_AVERAG_NOQRS:
							FinalStatus = AnalysisStatus.GRIERR_ANLYS_NO_QRS;
							break;
			case E_WAVTYP_ALIGN:
			case E_WAVTYP_MAXCLASS:
			case E_WAVTYP_ALIGN_WIDE:
							FinalStatus = AnalysisStatus.GRIERR_ANLYS_WAVETYPING;
							break;
			case E_AVERAG_MODE:
			case EXIT_LEAD_PLACE:
			case EXIT_CMPLX_CALIBRATION:
			case EXIT_ECG_CALIBRATION:
			case EXIT_LOW_QRS_COUNT:
			case EXIT_HIGH_QRS_COUNT:
			case EXIT_ZERO_DURATION:
							FinalStatus = AnalysisStatus.GRIERR_ANLYS_MEAS_INVALID;
							break;
			case EXIT_WAV_LEAD_AVAIL:
			case EXIT_LEAD_AVAIL:
							FinalStatus = AnalysisStatus.GRIERR_ANLYS_MEAS_INVALID;
							break;
			default:		FinalStatus = AnalysisStatus.GRIERR_ANLYS_UNDEFINED;
							break;
		};

		return FinalStatus;
	}
	
	// ----------------------------------------------------------------------
	
	/**
	 * Pre-processes and analyses the pre-loaded ECG data. Handles the
	 * possibility of an error return from the analysis that could leave
	 * the analysis results structures in an undefined state. If an error
	 * return is detected, a dummy statement is set up to ensure that
	 * a basic interpretation comment can be printed but no measurements or
	 * representative beats should be printed.
	 * 
	 * @return	The {@link AnalysisStatus} enumerated exit status from the
	 * ECG analysis library.
	 */
	public AnalysisStatus Analyse()
	{

		// ------------------------------------------------------------------
		// Invoke analysis via JNI
		// ------------------------------------------------------------------
		
		//Log.d( TAG, "Invoking analysis..." );
		this.LibAnalysisStatus = jGriAnalysed();
		
		// Check the analysis status - any kind of error will leave the 
		// analysis results structures in an undefined state.
		if ( LibAnalysisStatus != E_GRI_OK )
		{
			// Set up dummy tuple as the analysis could have failed at early
			// or late stage. Set up the tuple to report 'recording unsuitable
			// for analysis'.
			this.statementTuples.clearTuples();
			this.statementTuples.addTuple( (short) 13, (short) 1, 3); 
		}
		else
		{
			// --------------------------------------------------------------
			// The scalar and vector matrices are returned via JNI as 2D
			// arrays. Convert them both to class based leads and globals for
			// easier access. 
			// --------------------------------------------------------------
			
			this.measMatrix.ScalarMeasToGlobalMeas();
			this.measMatrix.ScalarMeasToLeadMeas( this.ecgInfo.isPaediatricElectrodePlacement() );
			this.measMatrix.VectorToVectMeas();
		}
		
		// ------------------------------------------------------------------
		// The call the method to retrieve the set of interpretation statement
		// strings from the strings resource.
		// ------------------------------------------------------------------
		statementTuples.getStatementText( this.appContext );
		

		// ------------------------------------------------------------------
		// Return the simplified analysis status
		// ------------------------------------------------------------------
		return this.simplifyAnalysisStatus();
	}
	
	// ----------------------------------------------------------------------

	public short getNumberOfLeads()
	{
		return this.ecgInfo.NumberOfLeads;
	}
	
	// ----------------------------------------------------------------------

	/**
	 * Saves the analysis results to a series of text files. This is for
	 * debugging purposes only.
	 * 
	 * @param EcgFile	Instance providing names of the relevant output files.
	 */
	public void SaveResults( EcgDataFileName EcgFile )
	{
	    Log.d(TAG, "Saving results to file..." );
	    
	    GriBuildInfo	griBuildInfo = new  GriBuildInfo();

	    griBuildInfo.getBuildInfo();
	    // griBuildInfo.printContent();
	    
		this.measMatrix.saveScalarToTextFile( EcgFile.getMatrixFileName(), GRI_MAX_ECG_LEADS );
		this.measMatrix.saveVectorToTextFile( EcgFile.getVectorMatrixFileName() );
		this.measMatrix.printToTextFile( EcgFile.getEcgReportFileName(), this.controlInfo, this.ecgInfo.NumberOfLeads );
		
		this.statementTuples.saveTuplesToTextFile( EcgFile.getTuplesFileName() );
		this.statementTuples.printStatementsToTextFile( EcgFile.getInterpFileName() );
	}

	// ----------------------------------------------------------------------

	/**
	 * Saves the full ECG report to the specified file. The format of the report
	 * is the equivalent of supplying the -report parameter to the GRIANLYS
	 * tool.
	 *  
	 * @param EcgReportFileName	The name of the file (including path) to which
	 * the ECG report is to be written.
	 */
	public void SaveEcgReport( String EcgReportFileName )
	{
		
	}
	
	// ----------------------------------------------------------------------
	
	/**
	 * Dumps the contents of the patientInfo, controlInfo, ecgInfo and
	 * recordingInfo class instances to the output log.
	 */
	public void printInputContent()
	{
		short		i;


		Log.d( TAG, "###########################" );
		Log.d( TAG, "#    RestingEcg - Input   #" );
		Log.d( TAG, "###########################" );

		this.patientInfo.printContent();
		this.controlInfo.printContent();
		this.ecgInfo.printContent();
		this.recordingInfo.printContent();
		this.pacerInfo.printContent();

		Log.d( TAG, "IntegerLeads");
		Log.d( TAG, "============");
	    for ( i = 0; i < this.ecgInfo.NumberOfLeads; i++ )
	    {
	    	this.ecgLeads[i].printIntegerLead();
	    }

		Log.d( TAG, "###########################" );

	}
	
	// ----------------------------------------------------------------------
	
	/**
	 * Dumps the contents of the serialData, spatialVelocity and
	 * statementTuples class instances to the output log.
	 */
	public void printResultsContent()
	{
		short		i;

		
		Log.d( TAG, "###########################" );
		Log.d( TAG, "#   RestingEcg - Results  #" );
		Log.d( TAG, "###########################" );

		
		Log.d( TAG, "EcgLeads");
		Log.d( TAG, "========");
	    for ( i = 0; i < this.ecgInfo.NumberOfLeads; i++ )
	    {
	    	this.ecgLeads[i].printContent();
	    }
	    
		this.serialData.printContent();
	    this.spatialVelocity.printContent();
	    this.statementTuples.printContent();
	    this.statementTuples.printInterpText();		// Concise formatted statements

		Log.d( TAG, "RepresentativeBeats");
		Log.d( TAG, "===================");
	    for ( i = 0; i < this.ecgInfo.NumberOfLeads; i++ )
	    {
	    	this.ecgLeads[i].printRepresentativeBeat();
	    }

		Log.d( TAG, "BaselineCorrectedLeads");
		Log.d( TAG, "======================");
	    for ( i = 0; i < this.ecgInfo.NumberOfLeads; i++ )
	    {
	    	this.ecgLeads[i].printBaselineCorrectedLead();
	    }

		Log.d( TAG, "LeadMeas");
		Log.d( TAG, "======================");
	    for ( i = 0; i < this.ecgInfo.NumberOfLeads; i++ )
	    {
	    	this.measMatrix.leadMeas[i].printContent();
	    }

		Log.d( TAG, "###########################" );

	}

	public static void checkValue(RestingEcg restingEcg){
		GlobalMeas globalMeas = restingEcg.measMatrix.globalMeas;

		if(globalMeas.getQrsFrontalAxis() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setQrsFrontalAxis(RestingEcg.GRI_UNDEFINED_2);
		}

		if(globalMeas.getPFrontalAxis() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setPFrontalAxis(RestingEcg.GRI_UNDEFINED_2);
		}

		if(globalMeas.getSTFrontalAxis() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setSTFrontalAxis(RestingEcg.GRI_UNDEFINED_2);
		}

		if(globalMeas.getTFrontalAxis() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setTFrontalAxis(RestingEcg.GRI_UNDEFINED_2);
		}

		if(globalMeas.getQrsPsdoVec48SpatVel() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setQrsPsdoVec48SpatVel(RestingEcg.GRI_UNDEFINED_2);
		}

		if(globalMeas.getQrsPsdoVec58SpatVel() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setQrsPsdoVec58SpatVel(RestingEcg.GRI_UNDEFINED_2);
		}

		if(globalMeas.getQrsPsdoVec68SpatVel() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setQrsPsdoVec68SpatVel(RestingEcg.GRI_UNDEFINED_2);
		}

		if(globalMeas.getQrsPsdoVec78SpatVel() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setQrsPsdoVec78SpatVel(RestingEcg.GRI_UNDEFINED_2);
		}

		if(globalMeas.getQrsPsdoVecMaxAmpl() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setQrsPsdoVecMaxAmpl(RestingEcg.GRI_UNDEFINED_2);
		}
		//
		if(globalMeas.getOverallPOnset() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setOverallPOnset(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getOverallPTermination() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setOverallPTermination(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getOverallQrsOnset() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setOverallQrsOnset(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getOverallQrsTermination() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setOverallQrsTermination(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getOverallTOnset() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setOverallTOnset(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getOverallTTermination() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setOverallTTermination(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getHeartRateVariability() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setHeartRateVariability(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getStdDevNormRRIntervals() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setStdDevNormRRIntervals(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getLVHscore() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setLVHscore(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getLVstrain() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setLVstrain(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getOverallPDuration() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setOverallPDuration(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getOverallQrsDuration() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setOverallQrsDuration(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getOverallSTDuration() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setOverallSTDuration(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getOverallTDuration() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setOverallTDuration(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getRmaxaVR() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setRmaxaVR(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getRmaxaVL() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setRmaxaVL(RestingEcg.GRI_UNDEFINED_2);
		}

		//
		if(globalMeas.getOverallPRInterval() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setOverallPRInterval(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getOverallQTInterval() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setOverallQTInterval(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getHeartRate() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setHeartRate(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getPTerminalForceInV1() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setPTerminalForceInV1(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getQTDispersion() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setQTDispersion(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getQTc() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setQTc(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getFlags() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setFlags(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getQTcHodge() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setQTcHodge(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getQTcBazett() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setQTcBazett(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getQTcFridericia() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setQTcFridericia(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getQTcFramingham() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setQTcFramingham(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getSinusRate() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setSinusRate(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getSinusAverageRR() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setSinusAverageRR(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getVentRate() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setVentRate(RestingEcg.GRI_UNDEFINED_2);
		}
		if(globalMeas.getVentAverageRR() == RestingEcg.GRI_UNDEFINED){
			globalMeas.setVentAverageRR(RestingEcg.GRI_UNDEFINED_2);
		}


		LeadMeas[] leadMeas = restingEcg.measMatrix.leadMeas;
		for(int i=0;i<leadMeas.length;i++){
			LeadMeas item = leadMeas[i];

			if(item.getPPosAmplitude() == RestingEcg.GRI_UNDEFINED){
				item.setPPosAmplitude(RestingEcg.GRI_UNDEFINED_2);
			}
			if(item.getQAmplitude() == RestingEcg.GRI_UNDEFINED){
				item.setQAmplitude(RestingEcg.GRI_UNDEFINED_2);
			}
			if(item.getRAmplitude() == RestingEcg.GRI_UNDEFINED){
				item.setRAmplitude(RestingEcg.GRI_UNDEFINED_2);
			}
			if(item.getSAmplitude() == RestingEcg.GRI_UNDEFINED){
				item.setSAmplitude(RestingEcg.GRI_UNDEFINED_2);
			}
			if(item.getTposAmplitude() == RestingEcg.GRI_UNDEFINED){
				item.setTposAmplitude(RestingEcg.GRI_UNDEFINED_2);
			}
			if(item.getSTT28Amplitude() == RestingEcg.GRI_UNDEFINED){
				item.setSTT28Amplitude(RestingEcg.GRI_UNDEFINED_2);
			}
			if(item.getSTT38Amplitude() == RestingEcg.GRI_UNDEFINED){
				item.setSTT38Amplitude(RestingEcg.GRI_UNDEFINED_2);
			}
			if(item.getST60Amplitude() == RestingEcg.GRI_UNDEFINED){
				item.setST60Amplitude(RestingEcg.GRI_UNDEFINED_2);
			}
			if(item.getST80Amplitude() == RestingEcg.GRI_UNDEFINED){
				item.setST80Amplitude(RestingEcg.GRI_UNDEFINED_2);
			}
			if(item.getQDuration() == RestingEcg.GRI_UNDEFINED){
				item.setQDuration(RestingEcg.GRI_UNDEFINED_2);
			}
			if(item.getRDuration() == RestingEcg.GRI_UNDEFINED){
				item.setRDuration(RestingEcg.GRI_UNDEFINED_2);
			}
			if(item.getSDuration() == RestingEcg.GRI_UNDEFINED){
				item.setSDuration(RestingEcg.GRI_UNDEFINED_2);
			}
		}
	}
}
