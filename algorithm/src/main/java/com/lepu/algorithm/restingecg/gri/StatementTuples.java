package com.lepu.algorithm.restingecg.gri;

import android.content.Context;
import android.util.Log;

import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;

/**
 * Maintains the list of statement tuples generated by the analysis process.
 * 
 * @author  Brian Devine
 */
public class StatementTuples {

	// ----------------------------------------------------------------------	
	private static final String TAG = "MyActivity-StatementTuples";
	// ----------------------------------------------------------------------	

	static final short GRITUPLE_TYPE_REASON = 0;
	static final short GRITUPLE_TYPE_STATEMENT = 1;
	static final short GRITUPLE_TYPE_ADD_STATEMENT = 2;

	/**
	 * A {@link boolean} flag to indicate if the summary code tuple as been
	 * added to the list array {@link StatementTuple}
	 */
	private	boolean bSummaryCodeAdded;
	
	/**
	 * Number of tuples stored.
	 */
	public short		TupleCount;
	
	/**
	 * The maximum number of tuples that can be accommodated.
	 */
	public short		MaxTuples;
	
	
	/**
	 * Array of statement tuples that will be populated by {@link com.restingecg.gri.RestingEcg#Analyse()}
	 * method.
	 */
	public StatementTuple []	Tuples;
	

	// ----------------------------------------------------------------------
	// METHODS
	// ----------------------------------------------------------------------

	/**
	 * Constructure to create an array of {@link StatementTuple} capable of
	 * holding the maximum numbe of tuples specified.
	 *
	 * @param NumTuples	The maximum number of tuples to be accommodated.
	 */
	public StatementTuples( short NumTuples )
	{
		short	i;
		
		// Provide indication of the maximum number of pacers that can be stored
		MaxTuples = NumTuples;

		TupleCount = 0;
		
		Tuples = new StatementTuple [NumTuples];
		for ( i = 0; i < NumTuples; i++ )
		{
			Tuples[i] = new StatementTuple();
		}
	}
	
 	// ----------------------------------------------------------------------
	
	/**
	 * Appends the given statement tuple, consisting of Group, Type and Code,
	 * to the array of  {@link StatementTuple}. If the array of
	 * {@link StatementTuple} is full, the given statement tuple will not
	 * be appended.
	 * 
	 * @param Group	The group number of the given statement.
	 * @param Type	The type of the given statement.
	 * @param Code	The statement code of the given statement.
	 * @return TRUE if the tuple was successfully appended to the tuple
	 * list, otherwise returns FALSE.
	 * 
	 */
	public boolean addTuple( short Group, short Type, int Code )
	{
		if ( this.TupleCount < this.MaxTuples )
		{
			this.Tuples[TupleCount].setTuple( Group, Type, Code );
			this.TupleCount++;
			
			return true;
		}
		else
		{
			return false;
		}
	}

	
	// ----------------------------------------------------------------------
	
	/**
	 * Clears the entire tuple array, resetting all entries to null tuples
	 * and resetting the tuple count.
	 */
	public void clearTuples()
	{
		short	i;
	

		for ( i = 0; i < this.MaxTuples; i++ )
		{
			this.Tuples[i].setTuple( (short) 0, (short) 0, 0); 
		}
		this.TupleCount = 0;
	}
 	// ----------------------------------------------------------------------

	/**
	 * Lists the currently stored statement tuples. Each statement tuple will
	 * be listed as Group, Type and Code.
	 */
	public void printTuples()
	{
		short	i;
		
		Log.d( TAG, ">> STATEMENT TUPLES" );
		Log.d( TAG, "Max number of tuples  : " + MaxTuples );
		Log.d( TAG, "Tuple count           : " + TupleCount );
		for ( i = 0; i < TupleCount; i++ )
		{
			//Log.d( TAG, String.format( "[%2d] %3d  %2d  %5d", args)"[" + (i+1) + "] " + Tuples[i].Group + " " + Tuples[i].TextType + " " + Tuples[i].Code );
			Log.d( TAG, String.format( "[%2d] %3d  %2d  %5d", (i+1), Tuples[i].Group, Tuples[i].Type, Tuples[i].Code ) );
		}
	}
	
 	// ----------------------------------------------------------------------

	/**
	 * Determines the summary statement for the currently stored set of statement
	 * tuples.
	 * 
	 * The summary code can only be determined by inspection of the statement
	 * dictionary to determine the highest summary code for the tuples returned
	 * by the analysis software. Prior to calling this function, the statement
	 * text and summary code must alreay have been obtained by calling the
	 * {@link StatementTuple} method UpdateTupleInfo().
	 *  
	 * @param context	The application context, which provides access to the
	 * strings resource. 
	 */
	public void appendSummaryStatement(Context context)
	{
		boolean	bSummaryStatementStored;
		short	SummaryStatementIndex;
		short	TupleNum;
		short	MaxSummaryCode;

		SummaryStatementIndex = -1;
		bSummaryStatementStored = false;

		// ------------------------------------------------------------------
		// Make sure that this hasn't been called already. Return immediately
		// if summary statement already exists.
		// ------------------------------------------------------------------

		for ( TupleNum = 0; TupleNum < TupleCount; TupleNum++ )
		{
			if ( Tuples[TupleNum].Group == 14 )
			{
				bSummaryStatementStored = true;
				SummaryStatementIndex = TupleNum;
				break;
			}
		}
		if ( bSummaryStatementStored )
		{
			return;
		}

		
		// ------------------------------------------------------------------
		// Get the maximum summary code
		// ------------------------------------------------------------------

		MaxSummaryCode = 0;
		for ( TupleNum = 0; TupleNum < TupleCount; TupleNum++ )
		{
			if  ( Tuples[TupleNum].SummaryCode > MaxSummaryCode )
			{
				MaxSummaryCode = Tuples[TupleNum].SummaryCode;
			}
		}


		// ------------------------------------------------------------------
		// Append the summary statement tuple
		// ------------------------------------------------------------------
		Log.d(TAG,  "Highest summary code value is " + MaxSummaryCode );
		this.addTuple( (short) 14, (short) GRITUPLE_TYPE_STATEMENT, MaxSummaryCode + 8 );
		
	}
	
 	// ----------------------------------------------------------------------

	/**
	 * Takes the list of statement tuples and determines the statement text and
	 * summary code from the Strings resource file. This requires the application
	 * context to enable access to the Strings resource containing the statement
	 * text.
	 * 
	 * @param context	The application context, which provides access to the
	 * strings resource containing the statement dictionary. 
	 * @return	A string array containing the statement text for all statement
	 * tuples.
	 */
	public String[] getStatementText(Context context)
	{
		short	i;
		
		String[] StatementText = new String[TupleCount+1];		// Add an extra for the summary statement
		String[] StatementInfo;
		
		short	FinalSummaryCode = 0;
		short	SummaryCode;

	
		
		// For each tuple, get the statement details from the resource
		for ( i = 0; i < TupleCount; i++ )
		{
			Tuples[i].updateDictionaryInfo(context);
			
			StatementInfo = Tuples[i].getInfo();
			StatementText[i] = StatementInfo[0];
			SummaryCode = Short.parseShort(StatementInfo[1]);
			//Log.d( TAG, "GetStatementText: StatementText = " + StatementText[i] );
			
			// Update summary code
			if ( SummaryCode > FinalSummaryCode )
			{
				FinalSummaryCode = SummaryCode;
			}
		}

		
		// Add the summary statement tuple
		
		//Log.d( TAG, "GetStatementText: Highest summary code value is " + FinalSummaryCode );
		this.addTuple( (short)14, (short)GRITUPLE_TYPE_STATEMENT, FinalSummaryCode+8);
		Tuples[TupleCount-1].updateDictionaryInfo(context);
		StatementText[TupleCount-1] = Tuples[TupleCount-1].getStatementText();

		return StatementText;
	}

 	// ----------------------------------------------------------------------

 	/**
 	 * Saves the statement tuples to the specified text file. The format of
 	 * the file is consistent with the output from the GRIANLYS application,
 	 * with assists with the process of debugging.
 	 * 
 	 * @param FileName	The name of the file to which the statement tuples
 	 * are to be written.
 	 */
 	public void saveTuplesToTextFile( String FileName )
 	{
 		Log.d( TAG, "Printing tuples to file '" + FileName + "'" );

		short	i;
		String OutputText;

 			
        try
        {

	       	File myFile = new File( FileName );
	       	myFile.createNewFile();
	       	FileOutputStream fOut = new FileOutputStream(myFile);
	
	       	OutputStreamWriter myOutWriter = new OutputStreamWriter(fOut);
	       	
			for ( i = 0; i < this.TupleCount; i++ )
			{
				if ( !this.Tuples[i].isNullTuple() )
				{
					OutputText = String.format("%d,%d,%d\n", this.Tuples[i].getGroup(), this.Tuples[i].getType(),this.Tuples[i].getCode() );
					
					myOutWriter.append( OutputText );
				}
			}
	       	
			myOutWriter.close();
			fOut.close();
  	 
	    } 
		catch (java.io.IOException e)
		{
	
		    // @NOTIFY: do something if an IOException occurs.
			//Toast.makeText(this,"Sorry Text could't be added",Toast.LENGTH_LONG).show();
			Log.e( TAG,  "Problem saving tuples to file '" + FileName + "'" );
	    }		
 	}

 	// ----------------------------------------------------------------------
 	
 	/**
 	 * Prints the interpretation statements to the given file. This mimics
 	 * the operation of the GRIANLYS output function for printing
 	 * interpretation statements. Statement concatenation is applied and each
 	 * resulting statement is preceded with an indication of the type of
 	 * statement such as "Headline" as "[H]", "Rhythm" as "[R]", "Diagnostic"
 	 * as "[D]" and "Summary" as "[S]". 
 	 * 
 	 * @param FileName	The name of the file to which the interpretation
 	 * statements are to be written.
 	 */
 	public void printStatementsToTextFile( String FileName )
 	{
 		short	i;
		String[] Interpretation;


        try
        {

	       	File myFile = new File( FileName );
	       	myFile.createNewFile();
	       	FileOutputStream fOut = new FileOutputStream(myFile);
	
	       	OutputStreamWriter myOutWriter = new OutputStreamWriter(fOut);

	       	Interpretation = this.getInterpText();
			for ( i = 0; i < Interpretation.length; i++ )
			{
				myOutWriter.append( Interpretation[i] + "\n" );
			}
	       	
			myOutWriter.close();
			fOut.close();
  	 
	    } 
		catch (java.io.IOException e)
		{
			// @NOTIFY: do something if an IOException occurs.
			//Toast.makeText(this,"Sorry Text could't be added",Toast.LENGTH_LONG).show();
			Log.e( TAG,  "Problem saving interpretation to file '" + FileName + "'" );
	
	    }		

 	}

 	// ----------------------------------------------------------------------

 	/**
 	 * Scans through the list of statement tuples and determines the total
 	 * number of lines that the statements will occupy once printed. The
 	 * counting take account of the presence of 'null' tuples as well
 	 * as statement concatenation and statements that are simply just blank
 	 * text
 	 * 
 	 * @return	The count of the number of lines that the printed statements
 	 * would occupy.
 	 */
 	private short getPrintableStatementCount()
 	{
 		short		printableTuplesCount;
 		short	i;

 		printableTuplesCount = 0;
 		for ( i = 0; i < this.TupleCount; i++ )
 		{
 			// @DEBUG: Log.d( TAG, "Check tuple " + i );
 			if ( !this.Tuples[i].isNullTuple() && !this.Tuples[i].isBlankText() )
 			{
 				if ( !this.Tuples[i].isConcatenatedStatement() )
 				{
 					printableTuplesCount++;
 				}
 			}
 		}	
 		
 		return printableTuplesCount;
 	}
 	
 	// ----------------------------------------------------------------------

 	/**
 	 * Scans through the array of {@link StatementTuple} generated by the ECG
 	 * analysis and generates an array of strings that contains a
 	 * filtered list of output statements with concatenation of
 	 * statement strings where applicable. Statement tuples that map to blank
 	 * text will be ignored. Each statement {@link String} will be preceded
 	 * with an indication of the type of statement that it is e.g.
 	 * [H]   is a headline statement (including advisory statements)
 	 * [R]   is a rhythm statement
 	 * [D]   is a contour diagnostic statement
 	 * [S]   is a summary statement
 	 * 
 	 * @return	{@link String} array containing the printable statements preceded with
 	 * statement type indicators.
 	 */
 	public String[] getInterpText()
 	{
 		short	i;
 		short	printableTuplesCount;
 		String[] Interp;
 		short	StorageIndex;

 
 		// First, determine how many printable statements there are
 		printableTuplesCount = this.getPrintableStatementCount();


 		// Create storage array with results
 		Interp = new String[printableTuplesCount];
 		StorageIndex = -1;
 		for ( i = 0; i < this.TupleCount; i++ )
 		{
 			if ( !this.Tuples[i].isNullTuple() && !this.Tuples[i].isBlankText() )
 			{
 				if ( this.Tuples[i].isConcatenatedStatement() )
 				{
 					// Append statement to any previously stored statement
 					if ( StorageIndex < 0 )
 					{
 						StorageIndex++;
 					}
 					// @DEBUG: Log.d( TAG, "Adding concatenated statement " + StorageIndex);
 					Interp[StorageIndex] +=  this.Tuples[i].StatementText.substring(1);
 				}
 				else
 				{
 					// Store statement in next available slot
 					StorageIndex++;
 					Interp[StorageIndex] = this.Tuples[i].getStatementPrefix() + this.Tuples[i].StatementText;
 					// @DEBUG: Log.d( TAG, "Adding new statement " + StorageIndex );
 				}
 			}
 		}
 
 		return Interp;
 	}
 
 	// ----------------------------------------------------------------------
 	
	/**
	 * Prints the concatenated statements to the debug output log.
	 */
 	public void printInterpText()
 	{
 		String[]	Interp;
 		int			i;


 		Interp = this.getInterpText();
 		for ( i = 0; i < Interp.length; i++ )
 		{
			Log.d( TAG, "[" + i + "] [" + Interp[i] + "]" );
 		}
		Log.d( TAG, " " );
 	}

 	// ----------------------------------------------------------------------

	/**
	 * Prints the contents of the {@link StatementTuples} instance to the
	 * debug output log.
	 */
 	public void printContent()
 	{
 		int		i;


		Log.d( TAG, "StatementTuples" );
		Log.d( TAG, "===============" );
		Log.d( TAG, "Max tuples            : " + this.MaxTuples );
		Log.d( TAG, "Tuple Count           : " + this.TupleCount );

 		for ( i = 0; i < this.TupleCount; i++ )
 		{
 			Log.d( TAG, "[" + i + "] " + String.format( "[%2d,%2d,%6d]", this.Tuples[i].getGroup(),this.Tuples[i].getType(),this.Tuples[i].getCode()) + " [" + this.Tuples[i].getStatementText() + "]" );
 		}

		Log.d( TAG, " " );

 	}
}
