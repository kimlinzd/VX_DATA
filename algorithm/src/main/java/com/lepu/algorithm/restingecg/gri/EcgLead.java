package com.lepu.algorithm.restingecg.gri;

import android.util.Log;


/**
 * Maintains information related to the ECG signals to be analysed
 * as well as those that are created by the analysis process.
 * 
 * @author Brian Devine
 *
 */
public class EcgLead {
	// --------------------------------------------------------------------------	
	private static final String TAG = "MyActivity-EcgLead";
	// --------------------------------------------------------------------------	

	GriLeadId	leadId;					// Unique identifier for specific lead
	
	private boolean debuggingEnabled;
	short  ttest;
	/**
	 * Flag indicating if the lead is available for analysis or after analysis
	 * is complete.
	 */
	boolean		isAvailable;
	
	/**
	 * Flag indicating if the lead was originally recorded at source.
	 */
	boolean		isRecorded;
	
	/**
	 * Flag indicating if the lead is determined to be too noisy for inclusion
	 * in the analysis process.
	 */
	boolean		isNoisy;
	
	/**
	 * Flag indicating if the lead is derived i.e. reconstructed from a
	 * series of equations.
	 */
	boolean		isDerived;

	
	/**
	 * The raw integer lead data to be analysed.
	 */
	short []	IntLead;
	
	/**
	 * The floating point baseline corrected lead data at 1uV resolution that
	 * will be generated by the analysis process.
	 */
	float []	BaselineCorrected;
	
	/**
	 * The representative (average/median) beat generated by the analysis process.
	 */
	short []	RepresentativeBeat;		// The representative (average/median) beat


	// ----------------------------------------------------------------------
	// METHODS
	// ----------------------------------------------------------------------

	/**
	 * Creates an ECG lead with undefined lead identification
	 * 
	 * @param EcgSamples	The number of samples is the raw ECG lead. This
	 * should be 5000.
	 * @param RepBeatSamples	The number of samples in the representative beat.
	 * This should be 600.
	 */
	public EcgLead( short EcgSamples, short RepBeatSamples )
	{
		this( GriLeadId.GRI_LEADID_UNDEFINED, EcgSamples, RepBeatSamples );
	}
	
	// ----------------------------------------------------------------------

	/**
	 * Creates a set of ECGs leads with the given lead identification. The
	 * arrays for the raw ECG lead and the representative beat are
	 * created with the indicated number of samples.
	 * 
	 * @param LeadId	The {@link GriLeadId} lead identifier for the given lead.
	 * @param EcgSamples	The number of samples is the raw ECG lead. This
	 * should be 5000.
	 * @param RepBeatSamples	The number of samples in the representative beat.
	 * This should be 600.
	 */
	public EcgLead( GriLeadId LeadId, short EcgSamples, short RepBeatSamples )
	{
		this.debuggingEnabled   = false;

		this.leadId        = LeadId;
		
		this.isAvailable        = false;
		this.isRecorded         = false;
		this.isDerived          = false;
		
		this.IntLead            = new short [EcgSamples];
		this.BaselineCorrected  = new float [EcgSamples];
		
		this.RepresentativeBeat = new short [RepBeatSamples];
		
	}

	// ----------------------------------------------------------------------

	/**
	 * Sets the lead identifier for the given lead.
	 * 
	 * @param LeadId	The {@link GriLeadId} lead identifier for the lead.
	 */
	public void setLeadId( GriLeadId LeadId )
	{
		this.leadId = LeadId; 
	}

	// ----------------------------------------------------------------------

	/**
	 * Retrieves the lead identifier for the given ecgLead.
	 * 
	 * @return	The {@link GriLeadId} lead identifier for the lead.
	 */
	public GriLeadId getLeadId( )
	{ 
		return this.leadId;
	}

	// ----------------------------------------------------------------------

	/**
	 * Sets the integer lead data for processing by the C ECG analysis
	 * library.
	 * 
	 * @param IntLeadData	Array containing integer lead samples.
	 */
	public void setIntLeadData( short [] IntLeadData )
	{
		int		i;
		int		MaxSamples;
		
		MaxSamples = this.IntLead.length;
		if ( IntLeadData.length < MaxSamples )
			MaxSamples = IntLeadData.length;
		
		
		
		for ( i = 0; i < MaxSamples; i++ )
		{
			this.IntLead[i] = IntLeadData[i];
		}
	}

	// ----------------------------------------------------------------------
	
	/**
	 * Returns the array of sample values for the representative beat.
	 *  
	 * @return	Array of 600 elements containing samples for representative
	 * beat. The data will be at 1uV/LSB.
	 */
	public short [] getRepresentativeBeatData()
	{
		return this.RepresentativeBeat;
	}

	// ----------------------------------------------------------------------
	
	/**
	 * Populates the supplied array with the sample values for the
	 * representative beat.
	 *  
	 * @param RepBeat	An array of at least 600 elements that will receive
	 * the sample values for the representative beat. The data will be at
	 * 1uV/LSB
	 */
	public void getRepresentativeBeatData( short [] RepBeat )
	{
		int	i;
		int	MaxSamples;
		
		MaxSamples = this.RepresentativeBeat.length;
		if ( RepBeat.length < MaxSamples )
			MaxSamples = RepBeat.length;
		
		for ( i = 0; i < MaxSamples; i++ )
		{
			RepBeat[i] = this.RepresentativeBeat[i];
		}

	}

	// ----------------------------------------------------------------------

	/**
	 * Returns the array of sample values for the baseline corrected data.
	 *  
	 * @return	Array of 5000 elements containing sample values for baseline
	 * corrected data. The data will be at 1uV/LSB.
	 */
	public float [] getBaselineCorrectedData()
	{
		return this.BaselineCorrected;
	}

	// ----------------------------------------------------------------------

	/**
	 * Populates the supplied array with the sample values for the
	 * baseline corrected data.
	 *  
	 * @param BaselineCorrected	An array of at least 5000 elements that will receive
	 * the sample values for the baseline corrected lead. The data will be 
	 * at 1uV/LSB.
	 */
	public void getBaselineCorrectedData( float [] BaselineCorrected )
	{
		int	i;
		int	MaxSamples;
		
		MaxSamples = this.BaselineCorrected.length;
		if ( BaselineCorrected.length < MaxSamples )
			MaxSamples = BaselineCorrected.length;
		
		for ( i = 0; i < MaxSamples; i++ )
		{
			BaselineCorrected[i] = this.BaselineCorrected[i];
		}

	}

	// ----------------------------------------------------------------------

	/**
	 * Returns the array of sample values for the integer data.
	 *  
	 * @return	An array of 5000 elements that will contain
	 * the sample values for the integer lead data. The data will be at
	 * the resolution defined in EcgInfo.LSBPerMV. 
	 */
	public short [] getIntLeadData()
	
	{
		return this.IntLead;
	}

	// ----------------------------------------------------------------------

	/**
	 * Populates the supplied array with the sample values for the
	 * baseline corrected data.
	 *  
	 * @param IntLeadData	An array of at least 5000 elements that will receive
	 * the sample values for the baseline corrected lead. The data will be at
	 * the resolution defined in EcgInfo.LSBPerMV. 
	 */
	public void getIntLeadData( short [] IntLeadData )
	
	{
		int	i;
		int	MaxSamples;
		
		MaxSamples = this.IntLead.length;
		if ( IntLeadData.length < MaxSamples )
			MaxSamples = IntLeadData.length;
		
		for ( i = 0; i < MaxSamples; i++ )
		{
			IntLeadData[i] = this.IntLead[i];
		}

	}

	// ----------------------------------------------------------------------

	/**
	 * Flags the lead as being available.
	 */
	public void setAvailable()
	{
		this.isAvailable = true;
	}

	// ----------------------------------------------------------------------

	/**
	 * Flags the lead as being unavailable.
	 */
	public void setUnavailable()
	{
		this.isAvailable = false;
	}

	// ----------------------------------------------------------------------

	/**
	 * Flags the lead as being available.
	 */
	public void setRecorded()
	{
		this.isRecorded = true;
	}

	// ----------------------------------------------------------------------

	/**
	 * Flags the lead as not being recorded.
	 */
	public void setNotRecorded()
	{
		this.isRecorded = false;
	}

	// ----------------------------------------------------------------------

	/**
	 * Flags the lead as being noisy.
	 */
	public void setNoisy()
	{
		this.isNoisy = true;
	}

	// ----------------------------------------------------------------------

	/**
	 * Flags the lead as not being noisy.
	 */
	public void setNotNoisy()
	{
		this.isNoisy = false;
	}

	// ----------------------------------------------------------------------

	/**
	 * Flags the lead as being derived.
	 */
	public void setDerived()
	{
		this.isDerived = true;
	}

	// ----------------------------------------------------------------------

	/**
	 * Flags the lead as not being derived.
	 */
	public void setNotDerived()
	{
		this.isDerived = false;
	}

	// ----------------------------------------------------------------------

	/**
	 * Prints the contents of the integer lead data buffers to the debug
	 * output log.
	 */
	public void printIntegerLead()
	{
		int			i;
		String result;

		Log.d( TAG, "Integer lead (" + this.leadId.getLabel() + ")(" + this.leadId.getValue() + ") :-" );
		Log.d( TAG, "  Length   : " + this.IntLead.length );
		result = "";
		for ( i = 0; i < 10; i++ )
		{
			result = result + String.format( "%8d ", this.IntLead[i] );
		}
		Log.d( TAG, "    First 10 samples: " + result );
		result = "";
		for ( i = this.IntLead.length - 10; i < this.IntLead.length; i++ )
		{
			result = result + String.format( "%8d ", this.IntLead[i] );
		}
		Log.d( TAG, "    Last  10 samples: " + result );

	}

	// ----------------------------------------------------------------------

	/**
	 * Prints the contents of the representative beat data buffers to the debug
	 * output log.
	 */
	public void printRepresentativeBeat()
	{
		int			i;
		String result;

		Log.d( TAG, "Representative beat (" + this.leadId.getLabel() + ")(" + this.leadId.getValue() + ") :-" );
		Log.d( TAG, "  Length   : " + this.RepresentativeBeat.length );
		result = "";
		for ( i = 0; i < 10; i++ )
		{
			result = result + String.format( "%8d ", this.RepresentativeBeat[i] );
		}
		Log.d( TAG, "    First 10 samples: " + result );
		result = "";
		for ( i = this.RepresentativeBeat.length - 10; i < this.RepresentativeBeat.length; i++ )
		{
			result = result + String.format( "%8d ", this.RepresentativeBeat[i] );
		}
		Log.d( TAG, "    Last  10 samples: " + result );
		
	}
	
	// ----------------------------------------------------------------------

	/**
	 * Prints the contents of the floating point baseline corrected lead data
	 * buffers to the debug output log.
	 */
	public void printBaselineCorrectedLead()
	{
		int			i;
		String result;

		Log.d( TAG, "Baseline corrected lead (" + this.leadId.getLabel() + ")(" + this.leadId.getValue() + ") :-" );
		Log.d( TAG, "  Length   : " + this.BaselineCorrected.length );
		result = "";
		for ( i = 0; i < 10; i++ )
		{
			result = result + String.format( "%f ", this.BaselineCorrected[i] );
		}
		Log.d( TAG, "    First 10 samples: " + result );
		result = "";
		for ( i = this.BaselineCorrected.length - 10; i < this.BaselineCorrected.length; i++ )
		{
			result = result + String.format( "%f ", this.BaselineCorrected[i] );
		}
		Log.d( TAG, "    Last  10 samples: " + result );
		
	}

	// ----------------------------------------------------------------------

	/**
	 * Prints the status information for the lead.
	 */
	public void printInfo()
	{
		Log.d( TAG, "Lead Info" );
		Log.d( TAG, "  Lead " + this.leadId.getValue() + " (" + this.leadId.getLabel() + ")" );
		Log.d( TAG, "  isAvailable    : " + this.isAvailable );
		Log.d( TAG, "  isRecorded     : " + this.isRecorded );
		Log.d( TAG, "  isNoisy        : " + this.isNoisy );
		Log.d( TAG, "  isDerived      : " + this.isDerived );
		Log.d( TAG, " " );
	}

	// ----------------------------------------------------------------------

	/**
	 * Prints out the first and last 10 samples all lead buffers of the given
	 * lead. The primary purpose of this is to confirm that the sample values
	 * match those from the C library.
	 */
	public void printContent()
	{
		this.printInfo();
		this.printIntegerLead();
		this.printRepresentativeBeat();
		this.printBaselineCorrectedLead();
	}
};
